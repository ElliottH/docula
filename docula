#!/usr/bin/env ruby

require 'optparse'
require 'digest/md5'

require 'rubygems'
require 'sqlite3'
require 'treetop'

require 'lib/grammars/csimple_nodes'
require 'lib/grammars/csimple'

require 'lib/utils'
require 'lib/db_utils'

require 'lib/input'

parsers = {
            '.c' => CSimpleParser,
            '.h' => CSimpleParser
          }

options = { :directory => Dir.pwd }
OptionParser.new do |o|
  o.banner = ''
  o.on('-d', '--directory DIRECTORY', 'Run in DIRECTORY.') do |d|
    options[:directory] = d
  end
  o.on('-f', '--force', 'Force reparsing of all files.') do |f|
    options[:force] = f
  end
  o.on('-h', '--help', 'Output this help and exit.') { puts o; exit }
  o.on('-v', '--verbose', 'Run verbosely') { |v| options[:verbose] = v }
  o.parse!
end

print "Running in directory #{options[:directory]}" if options[:verbose]
Dir.mkdir(".docula") unless File.directory?(".docula")

db = SQLite3::Database.new(".docula/db.sqlite")
DBUtils.setup(db)
file_chk_stmt = db.prepare("SELECT hash FROM files WHERE path = ?")
file_ins_stmt = db.prepare("INSERT INTO files (path, hash, docstring) VALUES (?, ?, ?)")
file_del_stmt = db.prepare("DELETE FROM files WHERE path = ?")

Dir.recurse(options[:directory]) do |file|
  if parsers[File.extname(file)]
    print "Parsing #{file} with #{parsers[File.extname(file)]}... " if options[:verbose]

    contents = File.read(file)
    hash = Digest::MD5.hexdigest(contents)

    fhash = file_chk_stmt.execute(file)
    row = fhash.next
    if row == nil || row['hash'] != hash || options[:force]
      file_del_stmt.execute(file)
      tree = CSimpleParser.new.parse(contents)
      if tree
        print "Success!\n" if options[:verbose]
        file_ins_stmt.execute(file, hash, tree.docstrings.map { |doc| doc.strip }.join('\n'))
        parse tree, db, db.last_insert_row_id, options
      else
        print "Failed!\n" if options[:verbose]
        print "Failed to parse #{file} with #{parsers[File.extname(file)]}!" unless options[:verbose]
      end
    end
  end
end
