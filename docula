#!/usr/bin/env ruby

require 'optparse'
require 'digest/md5'

require 'rubygems'
require 'sqlite3'
require 'treetop'

require 'lib/grammars/csimple_nodes'
require 'lib/grammars/csimple'

require 'lib/utils'
require 'lib/db_utils'

require 'lib/input'
require 'lib/html_output'

parsers = {
            '.c' => CSimpleParser,
            '.h' => CSimpleParser
          }
outputs = {
            'HTML' => HtmlOutput
          }

options = {
  :directory => Dir.pwd,
  :output => "output",
  :format => HtmlOutput
}
OptionParser.new do |o|
  o.banner = ''
  o.on('-d', '--directory DIRECTORY', 'Run in DIRECTORY.') do |d|
    options[:directory] = d
  end
  o.on('-o', '--output DIRECTORY', 'Output to DIRECTORY.') do |o|
    options[:output] = o
  end
  o.on('-f', '--force', 'Force reparsing of all files.') do |f|
    options[:force] = f
  end
  o.on("--format FORMAT", outputs, "Select output format",
          "  (#{outputs.keys})") do |format|
    options[:format] = format
  end
  o.on_tail('-h', '--help', 'Output this help and exit.') { puts o; exit }
  o.on('-v', '--verbose', 'Run verbosely') { |v| options[:verbose] = v }
  o.parse!
end

print "Running in directory #{options[:directory]}\n" if options[:verbose]
Dir.mkdir(".docula") unless File.directory?(".docula")

db = SQLite3::Database.new(".docula/db.sqlite")
DBUtils.setup(db)
file_chk_stmt = db.prepare("SELECT hash, id FROM files WHERE path = ?")
file_ins_stmt = db.prepare("INSERT INTO files (path, hash, docstring) VALUES (?, ?, ?)")
file_del_stmt = db.prepare("DELETE FROM files WHERE path = ?")
file_exist_stmt = db.prepare("UPDATE files SET exist = 1 WHERE id = ?")

db.execute("UPDATE files SET exist = 0")
Dir.recurse(options[:directory]) do |file|
  if parsers[File.extname(file)]
    print "Parsing #{file} with #{parsers[File.extname(file)]}... " if options[:verbose]

    contents = File.read(file)
    hash = Digest::MD5.hexdigest(contents)

    fhash = file_chk_stmt.execute(file)
    row = fhash.next
    if row == nil || row['hash'] != hash || options[:force]
      file_del_stmt.execute(file)
      parser = parsers[File.extname(file)].new
      tree = parser.parse(contents)
      if tree
        print "Success!\n" if options[:verbose]
        file_ins_stmt.execute(file, hash, tree.docstrings.map { |doc| doc.strip }.join('\n'))
        parse tree, db, db.last_insert_row_id, options
      else
        print "Failed!\n#{parser.failure_reason}\n" if options[:verbose]
        print "Failed to parse #{file} with #{parsers[File.extname(file)]}!\n" unless options[:verbose]
      end
    end
    file_exist_stmt.execute(row['id']) if row
  end
end
db.execute("DELETE FROM files WHERE exist = 0")

output = options[:format].new(db, options)
output.output
